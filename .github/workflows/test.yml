name: Test

on:
  push:
    branches: main
  pull_request:
    branches: main

jobs:
  build-and-test:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      # Cache path is relative to runner's workspace, not container's workspace
      - name: Cache vcpkg
        id: cache-vcpkg
        uses: actions/cache@v3
        with:
          path: ${{ github.workspace }}/build/vcpkg_installed
          key: ${{ runner.os }}-${{ hashFiles('vcpkg.json') }}

      - name: Cache Docker images
        id: cache-docker
        uses: actions/cache@v3
        with:
          path: /dockerfile
          key: dependencies-${{ hashFiles('./dockerfile/dependencies.Dockerfile')}}

      # Cache miss -> Download image and save
      - name: Pull Docker images if not in cache and save
        if: steps.cache-docker.outputs.cache-hit != 'true'
        run: |
          docker pull craftarc/axel:dependencies
          mkdir -p /dockerfile
          docker save -o /dockerfile/dependencies.tar craftarc/axel:dependencies

      # Cache hit -> The cache would have been restored -> Load the image
      - name: Load docker image if in cache
        if: steps.cache-docker.outputs.cache-hit == 'true'
        run: |
          docker load -i /dockerfile/dependencies.tar

      # docker compose takes care of mounting the project root and invoking the test script in the container
      - name: Start container and test
        run: |
          chmod 744 "scripts/workflows/test.sh"
          docker compose up test

      # Return to runner workspace before vcpkg caching takes place, otherwise cache path is invalid
      - name: Close container
        run: |
          docker compose down test
          
          

